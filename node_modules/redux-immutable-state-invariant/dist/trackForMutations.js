"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = trackForMutations;

function trackForMutations(isImmutable, obj) {
  var trackedProperties = trackProperties(isImmutable, obj);
  return {
    detectMutations: (function (_detectMutations) {
      function detectMutations() {
        return _detectMutations.apply(this, arguments);
      }

      detectMutations.toString = function () {
        return _detectMutations.toString();
      };

      return detectMutations;
    })(function () {
      return detectMutations(isImmutable, trackedProperties, obj);
    })
  };
}

function trackProperties(isImmutable, obj) {
  var tracked = { value: obj };

  if (!isImmutable(obj)) {
    tracked.children = {};

    for (var key in obj) {
      tracked.children[key] = trackProperties(isImmutable, obj[key]);
    }
  }
  return tracked;
}

function detectMutations(isImmutable, trackedProperty, obj) {
  var sameParentRef = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];
  var path = arguments.length <= 4 || arguments[4] === undefined ? [] : arguments[4];

  var prevObj = trackedProperty ? trackedProperty.value : undefined;

  var sameRef = prevObj === obj;

  if (sameParentRef && !sameRef) {
    return { wasMutated: true, path: path };
  }

  if (isImmutable(prevObj) || isImmutable(obj)) {
    return { wasMutated: false };
  }

  // Gather all keys from prev (tracked) and after objs
  var keys = {};
  Object.keys(trackedProperty.children).forEach(function (key) {
    keys[key] = true;
  });
  Object.keys(obj).forEach(function (key) {
    keys[key] = true;
  });

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = Object.keys(keys)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;

      var result = detectMutations(isImmutable, trackedProperty.children[key], obj[key], sameRef, path.concat(key));

      if (result.wasMutated) {
        return result;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"]) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return { wasMutated: false };
}
module.exports = exports["default"];